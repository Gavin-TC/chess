#include <stdlib.h>

#include <piece.h>
#include <constants.h>

Piece* createPiece(enum PieceType type, enum PieceColor color, int x, int y, int value, char chr) {
  Piece* new_piece = (Piece*) malloc(sizeof(Piece));

  if (new_piece == NULL) { return NULL; }

  new_piece->type = type;
  new_piece->color = color;
  new_piece->pos.x = x;
  new_piece->pos.y = y;
  new_piece->value = value;
  new_piece->chr = chr;

  return new_piece;
}

// TODO: is_player_first needs to be replaced with
// a parameter or a extern that is changed depending
// on whos turn it is.

bool isPieceMoveValid(Piece** pieces, Piece* chosen_piece, Piece* target_piece, int file1, int rank1, int file2, int rank2) {
  // 0: PAWN    3: ROOK
  // 1: BISHOP  4: QUEEN
  // 2: KNIGHT  5: KING
  
  if (target_piece != NULL) {
    // if the piece is ours
    if (target_piece->color == (is_player_first ? WHITE : BLACK)) {
      printf("You can't move a piece onto your own piece!\n");
      return false;
    }
  }
  
  switch (chosen_piece->type) {
    case 0:  // PAWN
      // if we're trying to move up 1/2 spaces and it's not on a piece 
      // (PAWN can move twice by default, add checks to see if it's moved before)
      // replace 1 and 2 with correct number based on player's piece
      
      if (file1 == file2 && rank2 == rank1 + (is_player_first ? -1 : 1)) {
        if (target_piece != NULL) {
          if (target_piece->pos.x == file2 && target_piece->pos.y == rank2) {
            printf("You can only attack diagonally with a pawn!\n");
            return false;
          }
        }
        return true;

        // if we're trying to go 2 spaces, check if its the first pawn move
      } else if (file1 == file2 && (rank2 == rank1 + (is_player_first) ? -2 : 2)
                 && chosen_piece->pos.x == (is_player_first ? 6 : 1)) {
        if (target_piece != NULL) {
          if (target_piece->pos.x == file2 && target_piece->pos.y == rank2) {
            printf("You can only attack diagonally with a pawn!\n");
            return false;
          }
        }
        return true;

      } else if (file2 == file1 - 1 || file2 == file1 + 1 && rank2 == rank1 + (is_player_first ? -1 : 1)) { 
        if (target_piece->pos.x == file2 && target_piece->pos.y == rank2) {
          return true;
        }
      }

      printf("You can't move the pawn there!\n");
      return false;
    
    case 1: // BISHOP
      int file_difference = file2 - file1;
      int rank_difference = rank2 - rank1;

      int file_zeroed = file_difference * -1;
      int rank_zeroed = rank_difference * -1;

      printf("file_difference = %d\n", file_difference);
      printf("rank_difference = %d\n", rank_difference);

      if (abs(file_difference) == abs(rank_difference)) {
        // now we need to loop through each tile
        // towards the destination and check if there's a piece.

        // if there's a piece blocking the movement
        for (int i = 0; i < file_difference; i += (file_difference < 0 ? -1 : 1)) {
          for (int j = 0; j < rank_difference; j += (rank_difference < 0 ? -1 : 1)) {
            for (int k = 0; k < 32; k++) {
              printf("file1 + i = %d\n", (file1 + i));
              printf("rank1 + j = %d\n\n", (rank1 + j));

              if (pieces[k]->pos.x == file1 + i && pieces[k]->pos.y == rank1 + j
                  && pieces[k] != target_piece) {
                printf("There is a piece blocking that move!\n");
                return false; 
              }
            }
          }
        }
      }
      
      printf("The bishop can only move diagonally!\n");
      return false;
    
    case 2:  // KNIGHT
      if (file2 == file1 + 1 && (rank2 == rank1 + 2 || rank2 == rank1 - 2)) {
        // up/down 2 right 1
        return true;
      } else if (file2 == file1 + 2 && (rank2 == rank1 + 1 || rank2 == rank1 - 1)) {
        // up/down 1 right 2
        return true;
      } else if (file2 == file1 - 1 && (rank2 == rank1 + 2 || rank2 == rank1 - 2)) {
        // up/down 2 left 1
        return true;
      } else if (file2 == file1 + 2 && (rank2 == rank1 + 1 || rank2 == rank1 - 1)) {
        // up/down 1 left 2
        return true;
      }

      printf("You can't move the knight there!");
      return false;
    
    case 3: // ROOK
      bool moving_vertical = rank1 == rank2;
      bool moving_horizontal = file1 == file2;

      int ver_difference = rank2 - rank1;
      int hor_difference = file2 - file1;

      if (moving_vertical) {
        for (int i = 0; i < ver_difference; i += (ver_difference < 0 ? -1 : 1)) {

        }
      } else if (moving_horizontal) {
        for (int i = 0; i < hor_difference; i += (hor_difference < 0 ? -1 : 1)) {

        }
      }

      return false;

    case 4: // QUEEN
      break;
    
    case 5: // KING
      break;
    
    default:
      printf("There was an issue making your move!\n");
  }

  return true;
}

void freePieces(Piece** pieces) {
  for (int y = 0; y < 32; y++) free(pieces[y]);
  free(pieces);
}
